var documenterSearchIndex = {"docs":
[{"location":"#Libtask","page":"Libtask","title":"Libtask","text":"","category":"section"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask is best explained by the docstring for TapedTask:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.TapedTask","category":"page"},{"location":"#Libtask.TapedTask","page":"Libtask","title":"Libtask.TapedTask","text":"TapedTask(dynamic_scope::Any, f, args...)\n\nConstruct a TapedTask with the specified dynamic_scope, for function f and positional arguments args.\n\nExtended Help\n\nThere are three central features of a TapedTask, which we demonstrate via three examples.\n\nResumption\n\njulia> function f()\n           for t in 1:2\n               produce(t)\n               t += 1\n           end\n           return nothing\n       end\nf (generic function with 1 method)\n\njulia> t = TapedTask(nothing, f);\n\njulia> consume(t)\n1\n\njulia> consume(t)\n2\n\njulia> consume(t)\n\n\nCopying\n\njulia> t2 = TapedTask(nothing, f);\n\njulia> consume(t2)\n1\n\njulia> t3 = copy(t2);\n\njulia> consume(t3)\n2\n\njulia> consume(t2)\n2\n\nScoped Values\n\njulia> function f()\n           produce(get_dynamic_scope())\n           produce(get_dynamic_scope())\n           return nothing\n       end\nf (generic function with 1 method)\n\njulia> t = TapedTask(1, f);\n\njulia> consume(t)\n1\n\njulia> set_dynamic_scope!(t, 2)\n\njulia> consume(t)\n2\n\n\n\n\n\n","category":"type"},{"location":"","page":"Libtask","title":"Libtask","text":"The functions discussed the above docstring (in addition to TapedTask itself) form the public interface of Libtask.jl. They divide neatly into two kinds of functions: those which are used to construct and manipulate TapedTasks, and those which are intended to be used inside a TapedTask.","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"First, manipulation of TapedTasks:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.consume\nBase.copy(::Libtask.TapedTask)\nLibtask.set_dynamic_scope!","category":"page"},{"location":"#Libtask.consume","page":"Libtask","title":"Libtask.consume","text":"consume(t::TapedTask)\n\nRun t until it makes a call to produce. If this is the first time that t has been called, it start execution from the entry point. If consume has previously been called on t, it will resume from the last produce call. If there are no more produce calls, nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy-Tuple{TapedTask}","page":"Libtask","title":"Base.copy","text":"Base.copy(t::TapedTask)\n\nMakes a completely independent copy of t. consume can be applied to either the copy of t or the original without advancing the state of the other.\n\n\n\n\n\n","category":"method"},{"location":"#Libtask.set_dynamic_scope!","page":"Libtask","title":"Libtask.set_dynamic_scope!","text":"set_dynamic_scope!(t::TapedTask, new_dynamic_scope)::Nothing\n\nSet the dynamic_scope of t to new_dynamic_scope. Any references to  LibTask.dynamic_scope in future calls to consume(t) (either directly, or implicitly via iteration) will see this new value.\n\nSee also: get_dynamic_scope.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Libtask","title":"Libtask","text":"The functions which enable special functionality inside a TapedTasks are:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.produce\nLibtask.get_dynamic_scope","category":"page"},{"location":"#Libtask.produce","page":"Libtask","title":"Libtask.produce","text":"produce(x)\n\nWhen run inside a TapedTask, will immediately yield to the caller, producing value x.\n\nSee also: Libtask.consume\n\n\n\n\n\n","category":"function"},{"location":"#Libtask.get_dynamic_scope","page":"Libtask","title":"Libtask.get_dynamic_scope","text":"get_dynamic_scope()\n\nReturns the dynamic scope associated to Libtask. If called from inside a TapedTask, this will return whatever is contained in its dynamic_scope field.\n\nSee also set_dynamic_scope!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Libtask.produce_value\nLibtask.is_produce_stmt\nLibtask.might_produce","category":"page"},{"location":"internals/#Libtask.produce_value","page":"Internals","title":"Libtask.produce_value","text":"produce_value(x::Expr)\n\nReturns the value that a produce statement returns. For example, for the statment produce(%x), this function will return %x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.is_produce_stmt","page":"Internals","title":"Libtask.is_produce_stmt","text":"is_produce_stmt(x)::Bool\n\ntrue if x is an expression of the form Expr(:call, produce, %x) or a similar :invoke expression, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.might_produce","page":"Internals","title":"Libtask.might_produce","text":"might_produce(sig::Type{<:Tuple})::Bool\n\ntrue if a call to method with signature sig is permitted to contain Libtask.produce statements.\n\nThis is an opt-in mechanism. the fallback method of this function returns false indicating that, by default, we assume that calls do not contain Libtask.produce statements.\n\n\n\n\n\n","category":"function"}]
}
