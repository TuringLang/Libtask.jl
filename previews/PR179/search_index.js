var documenterSearchIndex = {"docs":
[{"location":"#Libtask","page":"Libtask","title":"Libtask","text":"","category":"section"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask is best explained by the docstring for TapedTask:","category":"page"},{"location":"#Libtask.TapedTask","page":"Libtask","title":"Libtask.TapedTask","text":"TapedTask(taped_globals::Any, f, args...; kwargs...)\n\nConstruct a TapedTask with the specified taped_globals, for function f, positional arguments args, and keyword argument kwargs.\n\nExtended Help\n\nThere are three central features of a TapedTask, which we demonstrate via three examples.\n\nResumption\n\nThe function Libtask.produce has a special meaning in Libtask. You can insert it into regular Julia functions anywhere that you like. For example\n\njulia> function f()\n           for t in 1:2\n               produce(t)\n               t += 1\n           end\n           return nothing\n       end\nf (generic function with 1 method)\n\nIf you construct a TapedTask from f, and call Libtask.consume on it, you'll see\n\njulia> t = TapedTask(nothing, f);\n\njulia> consume(t)\n1\n\nThe semantics of this are that Libtask.consume runs the function f until it reaches the call to Libtask.produce, at which point it will return the argument to Libtask.produce.\n\nSubsequent calls to Libtask.produce will resume execution of f immediately after the last Libtask.produce statement that was hit.\n\njulia> consume(t)\n2\n\nWhen there are no more Libtask.produce statements to hit, calling Libtask.consume will return nothing:\n\njulia> consume(t)\n\n\nCopying\n\nTapedTasks can be copied. Doing so creates a completely independent object. For example:\n\njulia> t2 = TapedTask(nothing, f);\n\njulia> consume(t2)\n1\n\nIf we make a copy and advance its state, it produces the same value that the original would have produced:\n\njulia> t3 = copy(t2);\n\njulia> consume(t3)\n2\n\nMoreover, advancing the state of the copy has not advanced the state of the original, because they are completely independent copies:\n\njulia> consume(t2)\n2\n\nTapedTask-Specific Globals\n\nIt is often desirable to permit a copy of a task and the original to differ in very specific ways. For example, in the context of Sequential Monte Carlo, you might want the only difference between two copies to be their random number generator.\n\nA generic mechanism is available to achieve this. Libtask.get_taped_globals and Libtask.set_taped_globals! let you set and retrieve a variable which is specific to a given Libtask.TapedTask. The former can be called inside a function:\n\njulia> function f()\n           produce(get_taped_globals(Int))\n           produce(get_taped_globals(Int))\n           return nothing\n       end\nf (generic function with 1 method)\n\nThe first argument to Libtask.TapedTask is the value that Libtask.get_taped_globals will return:\n\njulia> t = TapedTask(1, f);\n\njulia> consume(t)\n1\n\nThe value that it returns can be changed between Libtask.consume calls:\n\njulia> set_taped_globals!(t, 2)\n\njulia> consume(t)\n2\n\nInts have been used here, but it is permissible to set the value returned by Libtask.get_taped_globals to anything you like.\n\nImplementation Notes\n\nUnder the hood, we implement a TapedTask by obtaining the IRCode associated to the original function, transforming it so that it implements the semantics required by the produce / consume interface, and placing it inside a MistyClosure to make it possible to execute.\n\nThere are two main considerations when transforming the IRCode. The first is to ensure that the \"state\" of a TapedTask can be copied, so that a TapedTask can be copied, and resumed later. The complete state of a TapedTask is given by its arguments, and the value associated to each ssa (these are initially undefined). To make it possible to copy the state of the ssa values, we place Base.RefValue{T}s into the captures of the MistyClosure which implements the TapedTask, one for each ssa in the IR (T is the type inferred for that ssa). A call is replaced by reading in values of ssas from these refs, applying the original operation, and writing the result to the ref associated to the instruction. For example, if the original snippet of IRCode is something like\n\n%5 = f(%3, _1)\n\nthe transformed IR would be something like\n\n%5 = ref_for_%3[]\n%6 = f(%5, _1)\n     ref_for_%5[] = %6\n\nSetting things up in this manner ensures that an independent copy is made by simply copying all of the refs. A deepcopy is required for correctness as, while the refs do not alias one another (by construction), their contents might. For example, two refs may contain the same Array, and in general the behaviour of a function depends on this relationship.\n\nThe second component of the transformation is implementing the produce mechanism, and the ability to resume computation from where we produced. Roughly speaking, the IRCode must be modified to ensure that whenever a produce call in encountered, the MistyClosure returns the argument to produce, and that subsequent calls resume computation immediately after the produce statement. This resumption is achieved by setting the value of a counter prior to returning following a produce statement – a sequence of comparisons against this counter, and GotoIfNot statement are inserted at the top of the IR. These are used to jump to the point in the code from which computation should resume. These are set up such that, when the TapedTask is first run, computation start froms the first statement. Observe that this is also facilitated by the ref mechanism discussed above, as it ensures that the state persists between calls to a MistyClosure.\n\nThe above gives the broad outline of how TapedTasks are implemented. We refer interested readers to the code, which is extensively commented to explain implementation details.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Libtask","title":"Libtask","text":"The functions discussed in the above docstring (in addition to TapedTask itself) form the public interface of Libtask.jl. They divide neatly into two kinds of functions: those which are used to manipulate TapedTasks, and those which are intended to be used inside a TapedTask. First, manipulation of TapedTasks:","category":"page"},{"location":"#Libtask.consume","page":"Libtask","title":"Libtask.consume","text":"consume(t::TapedTask)\n\nRun t until it makes a call to produce. If this is the first time that t has been called, it starts execution from the entry point. If consume has previously been called on t, it will resume from the last produce call. If there are no more produce calls, nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy-Tuple{TapedTask}","page":"Libtask","title":"Base.copy","text":"Base.copy(t::TapedTask)\n\nMakes a completely independent copy of t. consume can be applied to either the copy of t or the original without advancing the state of the other.\n\n\n\n\n\n","category":"method"},{"location":"#Libtask.set_taped_globals!","page":"Libtask","title":"Libtask.set_taped_globals!","text":"set_taped_globals!(t::TapedTask, new_taped_globals)::Nothing\n\nSet the taped_globals of t to new_taped_globals. Any calls to  get_taped_globals in future calls to consume(t) (either directly, or implicitly via iteration) will see this new value.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Libtask","title":"Libtask","text":"Functions for use inside a TapedTasks are:","category":"page"},{"location":"#Libtask.produce","page":"Libtask","title":"Libtask.produce","text":"produce(x)\n\nWhen run inside a TapedTask, will immediately yield to the caller, returning value x. Users will typically hit this function when calling consume.\n\nSee also: Libtask.consume\n\n\n\n\n\n","category":"function"},{"location":"#Libtask.get_taped_globals","page":"Libtask","title":"Libtask.get_taped_globals","text":"get_taped_globals(T::Type)\n\nWhen called from inside a call to a TapedTask, this will return whatever is contained in its taped_globals field.\n\nThe type T is required for optimal performance. If you know that the result of this operation must return a specific type, specify T. If you do not know what type it will return, pass Any – this will typically yield type instabilities, but will run correctly.\n\nSee also set_taped_globals!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Libtask.produce_value","page":"Internals","title":"Libtask.produce_value","text":"produce_value(x::Expr)\n\nReturns the value that a produce statement returns. For example, for the statment produce(%x), this function will return %x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.is_produce_stmt","page":"Internals","title":"Libtask.is_produce_stmt","text":"is_produce_stmt(x)::Bool\n\ntrue if x is an expression of the form Expr(:call, produce, %x) or a similar :invoke expression, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.might_produce","page":"Internals","title":"Libtask.might_produce","text":"might_produce(sig::Type{<:Tuple})::Bool\n\ntrue if a call to method with signature sig is permitted to contain Libtask.produce statements.\n\nThis is an opt-in mechanism. the fallback method of this function returns false indicating that, by default, we assume that calls do not contain Libtask.produce statements.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.stmt_might_produce","page":"Internals","title":"Libtask.stmt_might_produce","text":"stmt_might_produce(x, ret_type::Type)::Bool\n\ntrue if x might contain a call to produce, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.inc_args","page":"Internals","title":"Libtask.inc_args","text":"inc_args(stmt::T)::T where {T}\n\nReturns a new T which is equal to stmt, except any Arguments present in stmt are incremented by 1. For example\n\njulia> Libtask.inc_args(Core.ReturnNode(Core.Argument(1)))\n:(return _2)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.get_type","page":"Internals","title":"Libtask.get_type","text":"get_type(info::ADInfo, x)\n\nReturns the static / inferred type associated to x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask._typeof","page":"Internals","title":"Libtask._typeof","text":"_typeof(x)\n\nCentral definition of typeof, which is specific to the use-required in this package. Largely the same as Base._stable_typeof, differing only in a handful of situations, for example:\n\njulia> Base._stable_typeof((Float64,))\nTuple{DataType}\n\njulia> Libtask._typeof((Float64,))\nTuple{Type{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.replace_captures","page":"Internals","title":"Libtask.replace_captures","text":"replace_captures(oc::Toc, new_captures) where {Toc<:OpaqueClosure}\n\nGiven an OpaqueClosure oc, create a new OpaqueClosure of the same type, but with new captured variables. This is needed for efficiency reasons – if build_rrule is called repeatedly with the same signature and intepreter, it is important to avoid recompiling the OpaqueClosures that it produces multiple times, because it can be quite expensive to do so.\n\n\n\n\n\nreplace_captures(mc::Tmc, new_captures) where {Tmc<:MistyClosure}\n\nSame as replace_captures for Core.OpaqueClosures, but returns a new MistyClosure.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.BasicBlockCode","page":"Internals","title":"Libtask.BasicBlockCode","text":"module BasicBlockCode\n\nCopied over from Mooncake.jl in order to avoid making this package depend on Mooncake. Refer to Mooncake's developer docs for context on this file.\n\n\n\n\n\n","category":"module"},{"location":"internals/#Libtask.opaque_closure","page":"Internals","title":"Libtask.opaque_closure","text":"opaque_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)::Core.OpaqueClosure{<:Tuple, ret_type}\n\nConstruct a Core.OpaqueClosure. Almost equivalent to Core.OpaqueClosure(ir, env...; isva, do_compile), but instead of letting Core.compute_oc_rettype figure out the return type from ir, impose ret_type as the return type.\n\nWarning\n\nUser beware: if the Core.OpaqueClosure produced by this function ever returns anything which is not an instance of a subtype of ret_type, you should expect all kinds of awful things to happen, such as segfaults. You have been warned!\n\nExtended Help\n\nThis is needed because we make extensive use of our ability to know the return type of a couple of specific OpaqueClosures without actually having constructed them. Without the capability to specify the return type, we have to guess what type compute_ir_rettype will return for a given IRCode before we have constructed the IRCode and run type inference on it. This exposes us to details of type inference, which are not part of the public interface of the language, and can therefore vary from Julia version to Julia version (including patch versions). Moreover, even for a fixed Julia version it can be extremely hard to predict exactly what type inference will infer to be the return type of a function.\n\nFailing to correctly guess the return type can happen for a number of reasons, and the kinds of errors that tend to be generated when this fails tell you very little about the underlying cause of the problem.\n\nBy specifying the return type ourselves, we remove this dependence. The price we pay for this is the potential for segfaults etc if we fail to specify ret_type correctly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.misty_closure","page":"Internals","title":"Libtask.misty_closure","text":"misty_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)\n\nIdentical to opaque_closure, but returns a MistyClosure closure rather than a Core.OpaqueClosure.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.optimise_ir!","page":"Internals","title":"Libtask.optimise_ir!","text":"optimise_ir!(ir::IRCode, show_ir=false)\n\nRun a fairly standard optimisation pass on ir. If show_ir is true, displays the IR to stdout at various points in the pipeline – this is sometimes useful for debugging.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.build_callable","page":"Internals","title":"Libtask.build_callable","text":"build_callable(sig::Type{<:Tuple})\n\nReturns a MistyClosure which is used by TapedTask to implement the produce-consume interface. If this method has been called using sig in the current world age, will make a copy of an existing MistyClosure. If not, will derive it from scratch (derive the IR + compile it etc).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.LazyCallable","page":"Internals","title":"Libtask.LazyCallable","text":"LazyCallable\n\nUsed to implement static dispatch, while avoiding the need to construct the callable immediately. When constructed, just stores the signature of the callable and its return type. Constructs the callable when first called.\n\nAll type information is known, so it is possible to make this callable type stable provided that the return type is concrete.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Libtask.DynamicCallable","page":"Internals","title":"Libtask.DynamicCallable","text":"DynamicCallable\n\nLike LazyCallable, but without any type information. Used to implement dynamic dispatch.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Libtask.callable_ret_type","page":"Internals","title":"Libtask.callable_ret_type","text":"callable_ret_type(sig, produce_types)\n\nComputes the types which might possibly be returned from a TapedTask, where sig is the signature (something of the form Tuple{...}) of the function from which the TapedTask is constructed, and produce_types are the possible types which such a call might produce.\n\nIn general, computing produce_types requires analysing the produce type of any statment in the IR associated to sig which might produce. See locations where this function is called to see where this happens.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.fresh_copy","page":"Internals","title":"Libtask.fresh_copy","text":"fresh_copy(mc::T) where {T<:MistyClosure}\n\nCreates an independent copy of mc by (carefully) replacing the Refs it contains it its captures. The resuting MistyClosure is safe to run.\n\nThis is achieved by replacing most Refs with new Refs of the same (el)type, but with nothing stored in them – values will be stored in them when the new MistyClosure is called. The only exception are DynamicCallables and LazyCallables – these are constructed when the MistyClosures IR is derived, so fresh instances of them are placed in the associated Ref.\n\nThe position counter is reset to -1 (indicating that execution should proceed from the start of the IR, rather than eg. jumping to a line following a produce statement.\n\n\n\n\n\n","category":"function"}]
}
