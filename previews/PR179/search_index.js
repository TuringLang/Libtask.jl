var documenterSearchIndex = {"docs":
[{"location":"#Libtask","page":"Libtask","title":"Libtask","text":"","category":"section"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask is best explained by the docstring for TapedTask:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.TapedTask","category":"page"},{"location":"#Libtask.TapedTask","page":"Libtask","title":"Libtask.TapedTask","text":"TapedTask(dynamic_scope::Any, f, args...)\n\nConstruct a TapedTask with the specified dynamic_scope, for function f and positional arguments args.\n\nExtended Help\n\nThere are three central features of a TapedTask, which we demonstrate via three examples.\n\nResumption\n\nThe function Libtask.produce has a special meaning in Libtask. You can insert it into regular Julia functions anywhere that you like. For example\n\njulia> function f()\n           for t in 1:2\n               produce(t)\n               t += 1\n           end\n           return nothing\n       end\nf (generic function with 1 method)\n\nIf you construct a TapedTask from f, and call Libtask.consume on it, you'll see\n\njulia> t = TapedTask(nothing, f);\n\njulia> consume(t)\n1\n\nThe semantics of this are that Libtask.consume runs the function f until it reaches the call to Libtask.produce, at which point it will return the argument to Libtask.produce.\n\nSubsequent calls to Libtask.produce will resume execution of f immediately after the last Libtask.produce statement that was hit.\n\njulia> consume(t)\n2\n\nWhen there are no more Libtask.produce statements to hit, calling Libtask.consume will return nothing:\n\njulia> consume(t)\n\n\nCopying\n\nTapedTasks can be copied. Doing so creates a completely independent object. For example:\n\njulia> t2 = TapedTask(nothing, f);\n\njulia> consume(t2)\n1\n\nIf we make a copy and advance its state, it produces the same value that the original would have produced:\n\njulia> t3 = copy(t2);\n\njulia> consume(t3)\n2\n\nMoreover, advancing the state of the copy has not advanced the state of the original, because they are completely independent copies:\n\njulia> consume(t2)\n2\n\nScoped Values\n\nIt is often desirable to permit a copy of a task and the original to differ in very specific ways. For example, in the context of Sequential Monte Carlo, you might want the only difference between two copies to be their random number generator.\n\nA generic mechanism is available to achieve this. Libtask.get_dynamic_scope and Libtask.set_dynamic_scope! let you set and retrieve a variable which is specific to a given Libtask.TapedTask. The former can be called inside a function:\n\njulia> function f()\n           produce(get_dynamic_scope())\n           produce(get_dynamic_scope())\n           return nothing\n       end\nf (generic function with 1 method)\n\nThe first argument to Libtask.TapedTask is the value that Libtask.get_dynamic_scope will return:\n\njulia> t = TapedTask(1, f);\n\njulia> consume(t)\n1\n\nThe value that it returns can be changed between Libtask.consume calls:\n\njulia> set_dynamic_scope!(t, 2)\n\njulia> consume(t)\n2\n\nInts have been used here, but it is permissible to set the value returned by Libtask.get_dynamic_scope to anything you like.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Libtask","title":"Libtask","text":"The functions discussed the above docstring (in addition to TapedTask itself) form the public interface of Libtask.jl. They divide neatly into two kinds of functions: those which are used to manipulate TapedTasks, and those which are intended to be used inside a TapedTask. First, manipulation of TapedTasks:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.consume\nBase.copy(::Libtask.TapedTask)\nLibtask.set_dynamic_scope!","category":"page"},{"location":"#Libtask.consume","page":"Libtask","title":"Libtask.consume","text":"consume(t::TapedTask)\n\nRun t until it makes a call to produce. If this is the first time that t has been called, it start execution from the entry point. If consume has previously been called on t, it will resume from the last produce call. If there are no more produce calls, nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy-Tuple{TapedTask}","page":"Libtask","title":"Base.copy","text":"Base.copy(t::TapedTask)\n\nMakes a completely independent copy of t. consume can be applied to either the copy of t or the original without advancing the state of the other.\n\n\n\n\n\n","category":"method"},{"location":"#Libtask.set_dynamic_scope!","page":"Libtask","title":"Libtask.set_dynamic_scope!","text":"set_dynamic_scope!(t::TapedTask, new_dynamic_scope)::Nothing\n\nSet the dynamic_scope of t to new_dynamic_scope. Any references to  LibTask.dynamic_scope in future calls to consume(t) (either directly, or implicitly via iteration) will see this new value.\n\nSee also: get_dynamic_scope.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Libtask","title":"Libtask","text":"Functions for use inside a TapedTasks are:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.produce\nLibtask.get_dynamic_scope","category":"page"},{"location":"#Libtask.produce","page":"Libtask","title":"Libtask.produce","text":"produce(x)\n\nWhen run inside a TapedTask, will immediately yield to the caller, producing value x.\n\nSee also: Libtask.consume\n\n\n\n\n\n","category":"function"},{"location":"#Libtask.get_dynamic_scope","page":"Libtask","title":"Libtask.get_dynamic_scope","text":"get_dynamic_scope()\n\nReturns the dynamic scope associated to Libtask. If called from inside a TapedTask, this will return whatever is contained in its dynamic_scope field.\n\nSee also set_dynamic_scope!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Libtask.produce_value\nLibtask.is_produce_stmt\nLibtask.might_produce\nLibtask.stmt_might_produce\nLibtask.LazyCallable\nLibtask.inc_args","category":"page"},{"location":"internals/#Libtask.produce_value","page":"Internals","title":"Libtask.produce_value","text":"produce_value(x::Expr)\n\nReturns the value that a produce statement returns. For example, for the statment produce(%x), this function will return %x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.is_produce_stmt","page":"Internals","title":"Libtask.is_produce_stmt","text":"is_produce_stmt(x)::Bool\n\ntrue if x is an expression of the form Expr(:call, produce, %x) or a similar :invoke expression, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.might_produce","page":"Internals","title":"Libtask.might_produce","text":"might_produce(sig::Type{<:Tuple})::Bool\n\ntrue if a call to method with signature sig is permitted to contain Libtask.produce statements.\n\nThis is an opt-in mechanism. the fallback method of this function returns false indicating that, by default, we assume that calls do not contain Libtask.produce statements.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.stmt_might_produce","page":"Internals","title":"Libtask.stmt_might_produce","text":"stmt_might_produce(x, ret_type::Type)::Bool\n\ntrue if x might contain a call to produce, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.LazyCallable","page":"Internals","title":"Libtask.LazyCallable","text":"\n\n\n\n","category":"type"},{"location":"internals/#Libtask.inc_args","page":"Internals","title":"Libtask.inc_args","text":"inc_args(stmt::T)::T where {T}\n\nReturns a new T which is equal to stmt, except any Arguments present in stmt are incremented by 1. For example\n\njulia> Libtask.inc_args(Core.ReturnNode(Core.Argument(1)))\n:(return _2)\n\n\n\n\n\n","category":"function"}]
}
