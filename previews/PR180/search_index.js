var documenterSearchIndex = {"docs":
[{"location":"#Libtask","page":"Libtask","title":"Libtask","text":"","category":"section"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask is best explained by the docstring for TapedTask:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.TapedTask","category":"page"},{"location":"#Libtask.TapedTask","page":"Libtask","title":"Libtask.TapedTask","text":"TapedTask(taped_globals::Any, f, args...; kwargs...)\n\nConstruct a TapedTask with the specified taped_globals, for function f, positional arguments args, and keyword argument kwargs.\n\nExtended Help\n\nThere are three central features of a TapedTask, which we demonstrate via three examples.\n\nResumption\n\nThe function Libtask.produce has a special meaning in Libtask. You can insert it into regular Julia functions anywhere that you like. For example\n\njulia> function f()\n           for t in 1:2\n               produce(t)\n               t += 1\n           end\n           return nothing\n       end\nf (generic function with 1 method)\n\nIf you construct a TapedTask from f, and call Libtask.consume on it, you'll see\n\njulia> t = TapedTask(nothing, f);\n\njulia> consume(t)\n1\n\nThe semantics of this are that Libtask.consume runs the function f until it reaches the call to Libtask.produce, at which point it will return the argument to Libtask.produce.\n\nSubsequent calls to Libtask.produce will resume execution of f immediately after the last Libtask.produce statement that was hit.\n\njulia> consume(t)\n2\n\nWhen there are no more Libtask.produce statements to hit, calling Libtask.consume will return nothing:\n\njulia> consume(t)\n\n\nCopying\n\nTapedTasks can be copied. Doing so creates a completely independent object. For example:\n\njulia> t2 = TapedTask(nothing, f);\n\njulia> consume(t2)\n1\n\nIf we make a copy and advance its state, it produces the same value that the original would have produced:\n\njulia> t3 = copy(t2);\n\njulia> consume(t3)\n2\n\nMoreover, advancing the state of the copy has not advanced the state of the original, because they are completely independent copies:\n\njulia> consume(t2)\n2\n\nTapedTask-Specific Globals\n\nIt is often desirable to permit a copy of a task and the original to differ in very specific ways. For example, in the context of Sequential Monte Carlo, you might want the only difference between two copies to be their random number generator.\n\nA generic mechanism is available to achieve this. Libtask.get_taped_globals and Libtask.set_taped_globals! let you set and retrieve a variable which is specific to a given Libtask.TapedTask. The former can be called inside a function:\n\njulia> function f()\n           produce(get_taped_globals(Int))\n           produce(get_taped_globals(Int))\n           return nothing\n       end\nf (generic function with 1 method)\n\nThe first argument to Libtask.TapedTask is the value that Libtask.get_taped_globals will return:\n\njulia> t = TapedTask(1, f);\n\njulia> consume(t)\n1\n\nThe value that it returns can be changed between Libtask.consume calls:\n\njulia> set_taped_globals!(t, 2)\n\njulia> consume(t)\n2\n\nInts have been used here, but it is permissible to set the value returned by Libtask.get_taped_globals to anything you like.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Libtask","title":"Libtask","text":"The functions discussed the above docstring (in addition to TapedTask itself) form the public interface of Libtask.jl. They divide neatly into two kinds of functions: those which are used to manipulate TapedTasks, and those which are intended to be used inside a TapedTask. First, manipulation of TapedTasks:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.consume\nBase.copy(::Libtask.TapedTask)\nLibtask.set_taped_globals!","category":"page"},{"location":"#Libtask.consume","page":"Libtask","title":"Libtask.consume","text":"consume(t::TapedTask)\n\nRun t until it makes a call to produce. If this is the first time that t has been called, it start execution from the entry point. If consume has previously been called on t, it will resume from the last produce call. If there are no more produce calls, nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy-Tuple{TapedTask}","page":"Libtask","title":"Base.copy","text":"Base.copy(t::TapedTask)\n\nMakes a completely independent copy of t. consume can be applied to either the copy of t or the original without advancing the state of the other.\n\n\n\n\n\n","category":"method"},{"location":"#Libtask.set_taped_globals!","page":"Libtask","title":"Libtask.set_taped_globals!","text":"set_taped_globals!(t::TapedTask, new_taped_globals)::Nothing\n\nSet the taped_globals of t to new_taped_globals. Any calls to  get_taped_globals in future calls to consume(t) (either directly, or implicitly via iteration) will see this new value.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Libtask","title":"Libtask","text":"Functions for use inside a TapedTasks are:","category":"page"},{"location":"","page":"Libtask","title":"Libtask","text":"Libtask.produce\nLibtask.get_taped_globals","category":"page"},{"location":"#Libtask.produce","page":"Libtask","title":"Libtask.produce","text":"produce(x)\n\nWhen run inside a TapedTask, will immediately yield to the caller, producing value x.\n\nSee also: Libtask.consume\n\n\n\n\n\n","category":"function"},{"location":"#Libtask.get_taped_globals","page":"Libtask","title":"Libtask.get_taped_globals","text":"get_taped_globals(T::Type)\n\nWhen called from inside a call to a TapedTask, this will return whatever is contained in its taped_globals field.\n\nThe type T is required for optimal performance. If you know that the result of this operation must return a specific type, specific T. If you do not know what type it will return, pass Any – this will typically yield type instabilities, but will run correctly.\n\nSee also set_taped_globals!.\n\nExtended Help\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Libtask.produce_value\nLibtask.is_produce_stmt\nLibtask.might_produce\nLibtask.stmt_might_produce\nLibtask.LazyCallable\nLibtask.inc_args\nLibtask.get_type\nLibtask._typeof\nLibtask.replace_captures\nLibtask.BasicBlockCode\nLibtask.opaque_closure\nLibtask.misty_closure\nLibtask.optimise_ir!","category":"page"},{"location":"internals/#Libtask.produce_value","page":"Internals","title":"Libtask.produce_value","text":"produce_value(x::Expr)\n\nReturns the value that a produce statement returns. For example, for the statment produce(%x), this function will return %x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.is_produce_stmt","page":"Internals","title":"Libtask.is_produce_stmt","text":"is_produce_stmt(x)::Bool\n\ntrue if x is an expression of the form Expr(:call, produce, %x) or a similar :invoke expression, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.might_produce","page":"Internals","title":"Libtask.might_produce","text":"might_produce(sig::Type{<:Tuple})::Bool\n\ntrue if a call to method with signature sig is permitted to contain Libtask.produce statements.\n\nThis is an opt-in mechanism. the fallback method of this function returns false indicating that, by default, we assume that calls do not contain Libtask.produce statements.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.stmt_might_produce","page":"Internals","title":"Libtask.stmt_might_produce","text":"stmt_might_produce(x, ret_type::Type)::Bool\n\ntrue if x might contain a call to produce, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.LazyCallable","page":"Internals","title":"Libtask.LazyCallable","text":"\n\n\n\n","category":"type"},{"location":"internals/#Libtask.inc_args","page":"Internals","title":"Libtask.inc_args","text":"inc_args(stmt::T)::T where {T}\n\nReturns a new T which is equal to stmt, except any Arguments present in stmt are incremented by 1. For example\n\njulia> Libtask.inc_args(Core.ReturnNode(Core.Argument(1)))\n:(return _2)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.get_type","page":"Internals","title":"Libtask.get_type","text":"get_type(info::ADInfo, x)\n\nReturns the static / inferred type associated to x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask._typeof","page":"Internals","title":"Libtask._typeof","text":"_typeof(x)\n\nCentral definition of typeof, which is specific to the use-required in this package.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.replace_captures","page":"Internals","title":"Libtask.replace_captures","text":"replace_captures(oc::Toc, new_captures) where {Toc<:OpaqueClosure}\n\nGiven an OpaqueClosure oc, create a new OpaqueClosure of the same type, but with new captured variables. This is needed for efficiency reasons – if build_rrule is called repeatedly with the same signature and intepreter, it is important to avoid recompiling the OpaqueClosures that it produces multiple times, because it can be quite expensive to do so.\n\n\n\n\n\nreplace_captures(mc::Tmc, new_captures) where {Tmc<:MistyClosure}\n\nSame as replace_captures for Core.OpaqueClosures, but returns a new MistyClosure.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.BasicBlockCode","page":"Internals","title":"Libtask.BasicBlockCode","text":"module BasicBlockCode\n\nCopied over from Mooncake.jl in order to avoid making this package depend on Mooncake. Refer to Mooncake's developer docs for context on this file.\n\n\n\n\n\n","category":"module"},{"location":"internals/#Libtask.opaque_closure","page":"Internals","title":"Libtask.opaque_closure","text":"opaque_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)::Core.OpaqueClosure{<:Tuple, ret_type}\n\nConstruct a Core.OpaqueClosure. Almost equivalent to Core.OpaqueClosure(ir, env...; isva, do_compile), but instead of letting Core.compute_oc_rettype figure out the return type from ir, impose ret_type as the return type.\n\nWarning\n\nUser beware: if the Core.OpaqueClosure produced by this function ever returns anything which is not an instance of a subtype of ret_type, you should expect all kinds of awful things to happen, such as segfaults. You have been warned!\n\nExtended Help\n\nThis is needed because we make extensive use of our ability to know the return type of a couple of specific OpaqueClosures without actually having constructed them. Without the capability to specify the return type, we have to guess what type compute_ir_rettype will return for a given IRCode before we have constructed the IRCode and run type inference on it. This exposes us to details of type inference, which are not part of the public interface of the language, and can therefore vary from Julia version to Julia version (including patch versions). Moreover, even for a fixed Julia version it can be extremely hard to predict exactly what type inference will infer to be the return type of a function.\n\nFailing to correctly guess the return type can happen for a number of reasons, and the kinds of errors that tend to be generated when this fails tell you very little about the underlying cause of the problem.\n\nBy specifying the return type ourselves, we remove this dependence. The price we pay for this is the potential for segfaults etc if we fail to specify ret_type correctly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.misty_closure","page":"Internals","title":"Libtask.misty_closure","text":"misty_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)\n\nIdentical to opaque_closure, but returns a MistyClosure closure rather than a Core.OpaqueClosure.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Libtask.optimise_ir!","page":"Internals","title":"Libtask.optimise_ir!","text":"optimise_ir!(ir::IRCode, show_ir=false)\n\nRun a fairly standard optimisation pass on ir. If show_ir is true, displays the IR to stdout at various points in the pipeline – this is sometimes useful for debugging.\n\n\n\n\n\n","category":"function"}]
}
